var tipuesearch = {"pages":[{"title":" ForDebug ","text":"ForDebug ForDebug : A Fortran library designed for debugging Fortran code, especially within pure procedures. fpm dependency If you want to use ForDebug as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] fordebug = { git = \"https://github.com/gha3mi/fordebug.git\" } Usage Error / Warning / Info Control use fordebug , only : debug type ( debug ) :: err call err % set (& severity = 1 , & code = 100 , & category = \"math\" , & message = \"division by zero\" , & location = my_module . f90 : 11 , & suggestion = \"Check denominator for zero.\" ) call err % print () call err % reset () Notes Define FOR_DEBUG preprocessor directive to enable error/warning/info control. Printing or Writing within Pure Procedures To enable printing or writing within a pure procedure in Fortran, use the fordebug module. use fordebug , only : pwrite ! within pure procedures call pwrite ( message = 'hello!' ) call pwrite ( R0i32 = n ) call pwrite ( message = 'x = ' , R0r32 = 1 0.0 , format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) Notes All arguments of pwrite are optional. Data types are represented using the following conventions: R0i32 , R0i64 , R0r32 , R0r64 , R0c32 , R0c64 for Rank 0 integer, real, and complex types. R1i32 , R1i64 , R1r32 , R1r64 , R1c32 , R1c64 for Rank 1 integer, real, and complex types. R2i32 , R2i64 , R2r32 , R2r64 , R2c32 , R2c64 for Rank 2 integer, real, and complex types. R0ch for Rank 0 character. Measuring Elapsed Time within Pure Procedures ForDebug uses ForTmie as dependency. For measuring elapsed time within a pure procedure, utilize the fordebug module with time derived type. use fordebug , only : timer , ptimer_start , ptimer_stop type ( timer ) :: t call ptimer_start ( t ) ! Perform your operations here call ptimer_stop ( t ) ! Output: Elapsed time:  0.000 [s] How to run examples Clone the repository: Clone the ForDebug repository from GitHub using the following command: git clone https://github.com/gha3mi/fordebug.git Navigate to the cloned directory: cd fordebug Running examples To run all examples, execute the following command: fpm run --example --all --flag \"-DFOR_DEBUG\" Status Compiler macos ubuntu windows flang-new - fpm ❌  cmake ✅ fpm ❌  cmake ❌ gfortran fpm ✅  cmake ✅ fpm ✅  cmake ✅ fpm ✅  cmake ✅ ifx - fpm ✅  cmake ✅ fpm ✅  cmake ❌ lfortran fpm ❌  cmake ❌ fpm ❌  cmake ❌ fpm ❌  cmake ❌ nvfortran - fpm ✅  cmake ✅ - API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForDebug using ford run the following\ncommand: ford README.yml Contributing Contributions to ForDebug are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. See also https://github.com/plevold/fortran-debug-utils. Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"debug – ForDebug ","text":"type, public :: debug Inherited by type~~debug~~InheritedByGraph type~debug debug type~my_type my_type type~my_type->type~debug err Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial logical, public :: ok = .true. .true. means no error/warning/info character(len=MAX_LENGTH_CATEGORY), private :: category category of error/warning/info integer, private :: code = NONE error/warning/info code, 0=none logical, private :: dbg = DEBUG_MODE debug mode flag character(len=MAX_LENGTH_LOCATION), private :: location location of error/warning/info character(len=MAX_LENGTH_MESSAGE), private :: message message of error/warning/info integer, private :: severity = NONE severity of the error, 0=none, 1=error, 2=warning, 3=info character(len=MAX_LENGTH_SUGGESTION), private :: suggestion suggestion for error/warning/info Type-Bound Procedures procedure, public :: print => print_error private impure subroutine print_error (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( debug ), intent(in) :: this procedure, public :: reset private pure elemental subroutine reset (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( debug ), intent(inout) :: this procedure, public :: set private pure elemental subroutine set (this, severity, code, category, message, location, suggestion) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( debug ), intent(inout) :: this integer, intent(in) :: severity integer, intent(in) :: code character(len=*), intent(in) :: category character(len=*), intent(in) :: message character(len=*), intent(in) :: location character(len=*), intent(in) :: suggestion Source Code type debug logical , private :: dbg = DEBUG_MODE !! debug mode flag logical :: ok = . true . !! .true. means no error/warning/info integer , private :: code = NONE !! error/warning/info code, 0=none integer , private :: severity = NONE !! severity of the error, 0=none, 1=error, 2=warning, 3=info character ( MAX_LENGTH_CATEGORY ), private :: category !! category of error/warning/info character ( MAX_LENGTH_LOCATION ), private :: location !! location of error/warning/info character ( MAX_LENGTH_MESSAGE ), private :: message !! message of error/warning/info character ( MAX_LENGTH_SUGGESTION ), private :: suggestion !! suggestion for error/warning/info contains procedure :: set procedure :: print => print_error procedure :: reset end type debug","tags":"","url":"type/debug.html"},{"title":"my_type – ForDebug ","text":"type, public :: my_type Inherits type~~my_type~~InheritsGraph type~my_type my_type type~debug debug type~my_type->type~debug err Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: a integer, public :: b type( debug ), public :: err Type-Bound Procedures procedure, public :: my_function private pure function my_function (this, a) result(b) Arguments Type Intent Optional Attributes Name class( my_type ), intent(in) :: this integer, intent(in) :: a Return Value integer procedure, public :: my_subroutine private pure subroutine my_subroutine (this, a) Arguments Type Intent Optional Attributes Name class( my_type ), intent(inout) :: this integer, intent(in) :: a Source Code type my_type integer :: a , b type ( debug ) :: err contains procedure :: my_function procedure :: my_subroutine end type my_type","tags":"","url":"type/my_type.html"},{"title":"impure_write – ForDebug","text":"impure subroutine impure_write(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Uses iso_fortran_env proc~~impure_write~~UsesGraph proc~impure_write impure_write iso_fortran_env iso_fortran_env proc~impure_write->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file Source Code pure subroutine impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) import int32 , int64 , real32 , real64 implicit none character ( * ), intent ( in ), optional :: message !! Message to print character ( * ), intent ( in ), optional :: file !! File to write to character ( * ), intent ( in ), optional :: format !! Format to use for printing character ( * ), intent ( in ), optional :: R0ch !! Rank=0, character integer ( int32 ), intent ( in ), optional :: R0i32 !! Rank=0, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R0i64 !! Rank=0, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R0r32 !! Rank=0, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R0r64 !! Rank=0, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R0c32 !! Rank=0, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R0c64 !! Rank=0, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R1i32 (:) !! Rank=1, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R1i64 (:) !! Rank=1, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R1r32 (:) !! Rank=1, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R1r64 (:) !! Rank=1, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R1c32 (:) !! Rank=1, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R1c64 (:) !! Rank=1, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R2i32 (:,:) !! Rank=2, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R2i64 (:,:) !! Rank=2, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R2r32 (:,:) !! Rank=2, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R2r64 (:,:) !! Rank=2, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R2c32 (:,:) !! Rank=2, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R2c64 (:,:) !! Rank=2, complex, kind=real64 character ( * ), intent ( in ), optional :: access !! Access mode for file end subroutine impure_write","tags":"","url":"proc/impure_write.html"},{"title":"impure_timer_start – ForDebug","text":"impure subroutine impure_timer_start(t) Uses fortime proc~~impure_timer_start~~UsesGraph proc~impure_timer_start impure_timer_start fortime fortime proc~impure_timer_start->fortime Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t Calls proc~~impure_timer_start~~CallsGraph proc~impure_timer_start impure_timer_start timer_start timer_start proc~impure_timer_start->timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine impure_timer_start ( t ) import timer implicit none type ( timer ), intent ( inout ) :: t end subroutine impure_timer_start","tags":"","url":"proc/impure_timer_start.html"},{"title":"impure_timer_stop – ForDebug","text":"impure subroutine impure_timer_stop(t, message) Uses fortime proc~~impure_timer_stop~~UsesGraph proc~impure_timer_stop impure_timer_stop fortime fortime proc~impure_timer_stop->fortime Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t character(len=*), intent(in), optional :: message Calls proc~~impure_timer_stop~~CallsGraph proc~impure_timer_stop impure_timer_stop timer_stop timer_stop proc~impure_timer_stop->timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine impure_timer_stop ( t , message ) import timer implicit none type ( timer ), intent ( inout ) :: t character ( len =* ), intent ( in ), optional :: message end subroutine impure_timer_stop","tags":"","url":"proc/impure_timer_stop.html"},{"title":"pure_subroutine – ForDebug","text":"pure subroutine pure_subroutine(x, n, y) Uses fordebug proc~~pure_subroutine~~UsesGraph proc~pure_subroutine pure_subroutine module~fordebug fordebug proc~pure_subroutine->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x integer, intent(in) :: n real(kind=rk), intent(out), allocatable :: y (:) Calls proc~~pure_subroutine~~CallsGraph proc~pure_subroutine pure_subroutine interface~ptimer_start ptimer_start proc~pure_subroutine->interface~ptimer_start interface~ptimer_stop ptimer_stop proc~pure_subroutine->interface~ptimer_stop interface~pwrite pwrite proc~pure_subroutine->interface~pwrite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pure_subroutine~~CalledByGraph proc~pure_subroutine pure_subroutine program~test1 test1 program~test1->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine pure_subroutine ( x , n , y ) use fordebug , only : timer , pwrite , ptimer_start , ptimer_stop implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'test/test1.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) ! nvfortran 25.5.0 -> NVFORTRAN-S-1074-Procedure call in Do Concurrent is not supported yet #if defined(__NVCOMPILER) do i = 2 , n #else do concurrent ( i = 2 : n ) #endif y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'test/test1.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'test/test1.txt' , access = 'append' ) end subroutine pure_subroutine","tags":"","url":"proc/pure_subroutine.html"},{"title":"pure_subroutine – ForDebug","text":"pure subroutine pure_subroutine(x, n, y) Uses fordebug proc~~pure_subroutine~2~~UsesGraph proc~pure_subroutine~2 pure_subroutine module~fordebug fordebug proc~pure_subroutine~2->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x integer, intent(in) :: n real(kind=rk), intent(out), allocatable :: y (:) Calls proc~~pure_subroutine~2~~CallsGraph proc~pure_subroutine~2 pure_subroutine interface~ptimer_start ptimer_start proc~pure_subroutine~2->interface~ptimer_start interface~ptimer_stop ptimer_stop proc~pure_subroutine~2->interface~ptimer_stop interface~pwrite pwrite proc~pure_subroutine~2->interface~pwrite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pure_subroutine~2~~CalledByGraph proc~pure_subroutine~2 pure_subroutine program~example_p example_p program~example_p->proc~pure_subroutine~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine pure_subroutine ( x , n , y ) use fordebug , only : timer , pwrite , ptimer_start , ptimer_stop implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'example/example_p.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) do concurrent ( i = 2 : n ) y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'example/example_p.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'example/example_p.txt' , access = 'append' ) end subroutine pure_subroutine","tags":"","url":"proc/pure_subroutine~2.html"},{"title":"debug_loc – ForDebug","text":"public pure function debug_loc(file, line) result(s) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer, intent(in) :: line Return Value character(len=256) Called by proc~~debug_loc~~CalledByGraph proc~debug_loc debug_loc program~simple simple program~simple->proc~debug_loc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function debug_loc ( file , line ) result ( s ) character ( * ), intent ( in ) :: file integer , intent ( in ) :: line character ( len = 256 ) :: s write ( s , '(a,\":\",i0)' ) trim ( file ), line end function debug_loc","tags":"","url":"proc/debug_loc.html"},{"title":"print_error – ForDebug","text":"private impure subroutine print_error(this) Type Bound debug Arguments Type Intent Optional Attributes Name class( debug ), intent(in) :: this Source Code impure subroutine print_error ( this ) class ( debug ), intent ( in ) :: this character ( len = 1 ) :: sev_letter character ( len =* ), parameter :: & ESC = char ( 27 ), & RED = ESC // \"[31m\" , & YEL = ESC // \"[33m\" , & BLU = ESC // \"[34m\" , & GRY = ESC // \"[90m\" , & RST = ESC // \"[0m\" character ( len = 5 ) :: color character ( len = 20 ) :: code_str character (:), allocatable :: line if ( this % dbg . and . . not . this % ok ) then select case ( this % severity ) case ( ERROR ); sev_letter = 'E' ; color = RED case ( WARNING ); sev_letter = 'W' ; color = YEL case ( INFO ); sev_letter = 'I' ; color = BLU case default ; sev_letter = 'N' ; color = GRY end select write ( code_str , '(i0)' ) this % code line = color // '[' // sev_letter // trim ( code_str ) // ']' // RST // ' ' // & '(' // GRY // trim ( this % location ) // RST // ') ' // & trim ( this % category ) // ': ' // & trim ( this % message ) if ( len_trim ( this % suggestion ) > 0 ) then line = line // ' [' // trim ( this % suggestion ) // ']' end if write ( * , '(a)' ) trim ( line ) end if end subroutine print_error","tags":"","url":"proc/print_error.html"},{"title":"reset – ForDebug","text":"private pure elemental subroutine reset(this) Type Bound debug Arguments Type Intent Optional Attributes Name class( debug ), intent(inout) :: this Called by proc~~reset~~CalledByGraph proc~reset debug%reset program~simple simple program~simple->proc~reset Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental subroutine reset ( this ) class ( debug ), intent ( inout ) :: this this % dbg = DEBUG_MODE this % ok = . true . this % code = NONE this % severity = NONE this % category = \"\" this % message = \"\" this % location = \"\" this % suggestion = \"\" end subroutine reset","tags":"","url":"proc/reset.html"},{"title":"set – ForDebug","text":"private pure elemental subroutine set(this, severity, code, category, message, location, suggestion) Type Bound debug Arguments Type Intent Optional Attributes Name class( debug ), intent(inout) :: this integer, intent(in) :: severity integer, intent(in) :: code character(len=*), intent(in) :: category character(len=*), intent(in) :: message character(len=*), intent(in) :: location character(len=*), intent(in) :: suggestion Called by proc~~set~~CalledByGraph proc~set debug%set program~simple simple program~simple->proc~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure elemental subroutine set ( this , severity , code , category , message , location , suggestion ) class ( debug ), intent ( inout ) :: this integer , intent ( in ) :: severity integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: category character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: location character ( len =* ), intent ( in ) :: suggestion if ( this % dbg ) then if ( severity /= NONE . and . severity /= ERROR . and . severity /= WARNING . and . severity /= INFO ) error stop \"Invalid severity level\" this % severity = severity this % code = code if ( this % code /= NONE . or . this % severity /= NONE ) this % ok = . false . this % category = trim ( category ) this % message = trim ( message ) this % suggestion = trim ( suggestion ) this % location = trim ( location ) end if end subroutine set","tags":"","url":"proc/set.html"},{"title":"ptimer_start – ForDebug","text":"interface Called by interface~~ptimer_start~~CalledByGraph interface~ptimer_start ptimer_start proc~pure_subroutine pure_subroutine proc~pure_subroutine->interface~ptimer_start proc~pure_subroutine~2 pure_subroutine proc~pure_subroutine~2->interface~ptimer_start program~example_p example_p program~example_p->proc~pure_subroutine~2 program~test1 test1 program~test1->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public pure module subroutine ptimer_start(t) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t","tags":"","url":"interface/ptimer_start.html"},{"title":"ptimer_stop – ForDebug","text":"interface Called by interface~~ptimer_stop~~CalledByGraph interface~ptimer_stop ptimer_stop proc~pure_subroutine pure_subroutine proc~pure_subroutine->interface~ptimer_stop proc~pure_subroutine~2 pure_subroutine proc~pure_subroutine~2->interface~ptimer_stop program~example_p example_p program~example_p->proc~pure_subroutine~2 program~test1 test1 program~test1->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public pure module subroutine ptimer_stop(t, message) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t character(len=*), intent(in), optional :: message","tags":"","url":"interface/ptimer_stop.html"},{"title":"pwrite – ForDebug","text":"interface Called by interface~~pwrite~~CalledByGraph interface~pwrite pwrite proc~pure_subroutine pure_subroutine proc~pure_subroutine->interface~pwrite proc~pure_subroutine~2 pure_subroutine proc~pure_subroutine~2->interface~pwrite program~example_p example_p program~example_p->proc~pure_subroutine~2 program~test1 test1 program~test1->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file","tags":"","url":"interface/pwrite.html"},{"title":"my_function – ForDebug","text":"private pure function my_function(this, a) result(b) Type Bound my_type Arguments Type Intent Optional Attributes Name class( my_type ), intent(in) :: this integer, intent(in) :: a Return Value integer Called by proc~~my_function~~CalledByGraph proc~my_function my_type%my_function proc~my_subroutine my_type%my_subroutine proc~my_subroutine->proc~my_function program~complex complex program~complex->proc~my_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function my_function ( this , a ) result ( b ) class ( my_type ), intent ( in ) :: this integer , intent ( in ) :: a integer :: b #if defined(FOR_DEBUG) if (. not . this % err % ok ) then b = 0 return end if #endif b = 2 / a end function my_function","tags":"","url":"proc/my_function.html"},{"title":"my_subroutine – ForDebug","text":"private pure subroutine my_subroutine(this, a) Type Bound my_type Arguments Type Intent Optional Attributes Name class( my_type ), intent(inout) :: this integer, intent(in) :: a Calls proc~~my_subroutine~~CallsGraph proc~my_subroutine my_type%my_subroutine proc~my_function my_type%my_function proc~my_subroutine->proc~my_function Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~my_subroutine~~CalledByGraph proc~my_subroutine my_type%my_subroutine program~complex complex program~complex->proc~my_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine my_subroutine ( this , a ) class ( my_type ), intent ( inout ) :: this integer , intent ( in ) :: a #if defined(FOR_DEBUG) if (. not . this % err % ok ) return if ( a == 0 ) then call this % err % set ( 1 , 100 , \"arithmetic/zero-division\" , \"Division by zero, denominator a = 0\" , debug_loc ( __ FILE__ , 26 ), \"Enforce precondition a /= 0\" ) return end if #endif this % b = this % my_function ( a ) end subroutine my_subroutine","tags":"","url":"proc/my_subroutine.html"},{"title":"impure_timer_start – ForDebug","text":"interface Called by interface~~impure_timer_start~~CalledByGraph interface~impure_timer_start impure_timer_start proc~ptimer_start ptimer_start proc~ptimer_start->interface~impure_timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. pure subroutine impure_timer_start(t) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t","tags":"","url":"interface/impure_timer_start.html"},{"title":"impure_timer_stop – ForDebug","text":"interface Called by interface~~impure_timer_stop~~CalledByGraph interface~impure_timer_stop impure_timer_stop proc~ptimer_stop ptimer_stop proc~ptimer_stop->interface~impure_timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. pure subroutine impure_timer_stop(t, message) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t character(len=*), intent(in), optional :: message","tags":"","url":"interface/impure_timer_stop.html"},{"title":"impure_write – ForDebug","text":"interface Called by interface~~impure_write~~CalledByGraph interface~impure_write impure_write proc~pwrite pwrite proc~pwrite->interface~impure_write Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. pure subroutine impure_write(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file","tags":"","url":"interface/impure_write.html"},{"title":"ptimer_start – ForDebug","text":"module procedure ptimer_start pure module subroutine ptimer_start(t) Interface → Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t Calls proc~~ptimer_start~~CallsGraph proc~ptimer_start ptimer_start interface~impure_timer_start impure_timer_start proc~ptimer_start->interface~impure_timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ptimer_start.html"},{"title":"ptimer_stop – ForDebug","text":"module procedure ptimer_stop pure module subroutine ptimer_stop(t, message) Interface → Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t character(len=*), intent(in), optional :: message Calls proc~~ptimer_stop~~CallsGraph proc~ptimer_stop ptimer_stop interface~impure_timer_stop impure_timer_stop proc~ptimer_stop->interface~impure_timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/ptimer_stop.html"},{"title":"pwrite – ForDebug","text":"module procedure pwrite pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file Calls proc~~pwrite~~CallsGraph proc~pwrite pwrite interface~impure_write impure_write proc~pwrite->interface~impure_write Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"proc/pwrite.html"},{"title":"fordebug – ForDebug","text":"Uses fortime iso_fortran_env module~~fordebug~~UsesGraph module~fordebug fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: fordebug_smod module~~fordebug~~UsedByGraph module~fordebug fordebug module~fordebug_smod fordebug_smod module~fordebug_smod->module~fordebug module~my_module my_module module~my_module->module~fordebug proc~pure_subroutine pure_subroutine proc~pure_subroutine->module~fordebug proc~pure_subroutine~2 pure_subroutine proc~pure_subroutine~2->module~fordebug program~simple simple program~simple->module~fordebug program~complex complex program~complex->module~my_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private, parameter :: DEBUG_MODE = .false. integer, private, parameter :: ERROR = 1 integer, private, parameter :: INFO = 3 integer, private, parameter :: MAX_LENGTH_CATEGORY = 32 integer, private, parameter :: MAX_LENGTH_LOCATION = 128 integer, private, parameter :: MAX_LENGTH_MESSAGE = 128 integer, private, parameter :: MAX_LENGTH_SUGGESTION = 128 integer, private, parameter :: NONE = 0 integer, private, parameter :: WARNING = 2 Interfaces interface public pure module subroutine ptimer_start(t) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t interface public pure module subroutine ptimer_stop(t, message) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t character(len=*), intent(in), optional :: message interface public pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file Derived Types type, public :: debug Components Type Visibility Attributes Name Initial logical, public :: ok = .true. .true. means no error/warning/info character(len=MAX_LENGTH_CATEGORY), private :: category category of error/warning/info integer, private :: code = NONE error/warning/info code, 0=none logical, private :: dbg = DEBUG_MODE debug mode flag character(len=MAX_LENGTH_LOCATION), private :: location location of error/warning/info character(len=MAX_LENGTH_MESSAGE), private :: message message of error/warning/info integer, private :: severity = NONE severity of the error, 0=none, 1=error, 2=warning, 3=info character(len=MAX_LENGTH_SUGGESTION), private :: suggestion suggestion for error/warning/info Type-Bound Procedures procedure, public :: print => print_error procedure, public :: reset procedure, public :: set Functions public pure function debug_loc (file, line) result(s) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer, intent(in) :: line Return Value character(len=256) Subroutines private impure subroutine print_error (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( debug ), intent(in) :: this private pure elemental subroutine reset (this) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( debug ), intent(inout) :: this private pure elemental subroutine set (this, severity, code, category, message, location, suggestion) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name class( debug ), intent(inout) :: this integer, intent(in) :: severity integer, intent(in) :: code character(len=*), intent(in) :: category character(len=*), intent(in) :: message character(len=*), intent(in) :: location character(len=*), intent(in) :: suggestion","tags":"","url":"module/fordebug.html"},{"title":"my_module – ForDebug","text":"Uses fordebug module~~my_module~~UsesGraph module~my_module my_module module~fordebug fordebug module~my_module->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~my_module~~UsedByGraph module~my_module my_module program~complex complex program~complex->module~my_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: my_type Components Type Visibility Attributes Name Initial integer, public :: a integer, public :: b type( debug ), public :: err Type-Bound Procedures procedure, public :: my_function procedure, public :: my_subroutine Functions private pure function my_function (this, a) result(b) Arguments Type Intent Optional Attributes Name class( my_type ), intent(in) :: this integer, intent(in) :: a Return Value integer Subroutines private pure subroutine my_subroutine (this, a) Arguments Type Intent Optional Attributes Name class( my_type ), intent(inout) :: this integer, intent(in) :: a","tags":"","url":"module/my_module.html"},{"title":"fordebug_smod – ForDebug","text":"Uses Ancestors: fordebug module~~fordebug_smod~~UsesGraph module~fordebug_smod fordebug_smod module~fordebug fordebug module~fordebug_smod->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface pure subroutine impure_timer_start(t) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t interface pure subroutine impure_timer_stop(t, message) Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t character(len=*), intent(in), optional :: message interface pure subroutine impure_write(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file Module Procedures module procedure /home/runner/work/fordebug/fordebug/doc/module/fordebug_smod.html ptimer_start pure module subroutine ptimer_start(t) Interface → Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t module procedure /home/runner/work/fordebug/fordebug/doc/module/fordebug_smod.html ptimer_stop pure module subroutine ptimer_stop(t, message) Interface → Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name type(timer), intent(inout) :: t character(len=*), intent(in), optional :: message module procedure /home/runner/work/fordebug/fordebug/doc/module/fordebug_smod.html pwrite pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Interface → Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file","tags":"","url":"module/fordebug_smod.html"},{"title":"test1 – ForDebug","text":"Uses iso_fortran_env program~~test1~~UsesGraph program~test1 test1 iso_fortran_env iso_fortran_env program~test1->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test1~~CallsGraph program~test1 test1 proc~pure_subroutine pure_subroutine program~test1->proc~pure_subroutine interface~ptimer_start ptimer_start proc~pure_subroutine->interface~ptimer_start interface~ptimer_stop ptimer_stop proc~pure_subroutine->interface~ptimer_stop interface~pwrite pwrite proc~pure_subroutine->interface~pwrite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:), allocatable :: y Subroutines pure subroutine pure_subroutine (x, n, y) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x integer, intent(in) :: n real(kind=rk), intent(out), allocatable :: y (:) Source Code program test1 use iso_fortran_env , only : rk => real64 implicit none #ifndef NOPURE_DEBUG real ( rk ), dimension (:), allocatable :: y call pure_subroutine ( 1 0.0_rk , 7 , y ) #endif #ifndef NOPURE_DEBUG contains pure subroutine pure_subroutine ( x , n , y ) use fordebug , only : timer , pwrite , ptimer_start , ptimer_stop implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'test/test1.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) ! nvfortran 25.5.0 -> NVFORTRAN-S-1074-Procedure call in Do Concurrent is not supported yet #if defined(__NVCOMPILER) do i = 2 , n #else do concurrent ( i = 2 : n ) #endif y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'test/test1.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'test/test1.txt' , access = 'append' ) end subroutine pure_subroutine #endif end program test1","tags":"","url":"program/test1.html"},{"title":"example_p – ForDebug","text":"Uses iso_fortran_env program~~example_p~~UsesGraph program~example_p example_p iso_fortran_env iso_fortran_env program~example_p->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~example_p~~CallsGraph program~example_p example_p proc~pure_subroutine~2 pure_subroutine program~example_p->proc~pure_subroutine~2 interface~ptimer_start ptimer_start proc~pure_subroutine~2->interface~ptimer_start interface~ptimer_stop ptimer_stop proc~pure_subroutine~2->interface~ptimer_stop interface~pwrite pwrite proc~pure_subroutine~2->interface~pwrite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:), allocatable :: y Subroutines pure subroutine pure_subroutine (x, n, y) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x integer, intent(in) :: n real(kind=rk), intent(out), allocatable :: y (:) Source Code program example_p use iso_fortran_env , only : rk => real64 implicit none real ( rk ), dimension (:), allocatable :: y print * , \" \" print * , \"Running example...\" #if defined (NOPURE_DEBUG) ! No pure debug #else call pure_subroutine ( 1 0.0_rk , 7 , y ) #endif #if defined (NOPURE_DEBUG) ! No pure debug #else contains pure subroutine pure_subroutine ( x , n , y ) use fordebug , only : timer , pwrite , ptimer_start , ptimer_stop implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'example/example_p.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) do concurrent ( i = 2 : n ) y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'example/example_p.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'example/example_p.txt' , access = 'append' ) end subroutine pure_subroutine #endif end program example_p","tags":"","url":"program/example_p.html"},{"title":"complex – ForDebug","text":"Uses my_module program~~complex~~UsesGraph program~complex complex module~my_module my_module program~complex->module~my_module module~fordebug fordebug module~my_module->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~complex~~CallsGraph program~complex complex proc~my_subroutine my_type%my_subroutine program~complex->proc~my_subroutine proc~my_function my_type%my_function proc~my_subroutine->proc~my_function Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( my_type ) :: obj Source Code program complex use my_module , only : my_type implicit none type ( my_type ) :: obj print * , \" \" print * , \"Running complex example...\" call obj % my_subroutine ( 0 ) call obj % err % print () end program complex","tags":"","url":"program/complex.html"},{"title":"simple – ForDebug","text":"Uses fordebug program~~simple~~UsesGraph program~simple simple module~fordebug fordebug program~simple->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~simple~~CallsGraph program~simple simple proc~debug_loc debug_loc program~simple->proc~debug_loc proc~reset debug%reset program~simple->proc~reset proc~set debug%set program~simple->proc~set Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( debug ) :: err Source Code program simple use fordebug , only : debug , debug_loc implicit none type ( debug ) :: err print * , \" \" print * , \"Running simple example...\" ! Info: starting a numerical solve call err % set (& severity = 3 , & code = 10 , & category = \"initialization\" , & message = \"Starting Cholesky factorization\" , & location = debug_loc ( __ FILE__ , 9 ), & suggestion = \"Proceed; this is a standard setup step.\" ) call err % print () ! Warning: potential numerical issue call err % set (& severity = 2 , & code = 20 , & category = \"numerical-warning\" , & message = \"Matrix is not positive definite\" , & location = \"simple.f90:18\" , & suggestion = \"Check matrix symmetry and eigenvalues before factorization.\" ) call err % print () ! Error: hard failure call err % set (& severity = 1 , & code = 30 , & category = \"arithmetic-error\" , & message = \"Division by zero detected in pivot step\" , & location = \"simple.f90:27\" , & suggestion = \"Ensure pivot elements are nonzero; consider partial pivoting.\" ) call err % print () call err % reset () end program simple","tags":"","url":"program/simple.html"},{"title":"test1.f90 – ForDebug","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~fordebug.f90 fordebug.F90 sourcefile~test1.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test1 use iso_fortran_env , only : rk => real64 implicit none #ifndef NOPURE_DEBUG real ( rk ), dimension (:), allocatable :: y call pure_subroutine ( 1 0.0_rk , 7 , y ) #endif #ifndef NOPURE_DEBUG contains pure subroutine pure_subroutine ( x , n , y ) use fordebug , only : timer , pwrite , ptimer_start , ptimer_stop implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'test/test1.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) ! nvfortran 25.5.0 -> NVFORTRAN-S-1074-Procedure call in Do Concurrent is not supported yet #if defined(__NVCOMPILER) do i = 2 , n #else do concurrent ( i = 2 : n ) #endif y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'test/test1.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'test/test1.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'test/test1.txt' , access = 'append' ) end subroutine pure_subroutine #endif end program test1","tags":"","url":"sourcefile/test1.f90.html"},{"title":"example_p.F90 – ForDebug","text":"This file depends on sourcefile~~example_p.f90~~EfferentGraph sourcefile~example_p.f90 example_p.F90 sourcefile~fordebug.f90 fordebug.F90 sourcefile~example_p.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program example_p use iso_fortran_env , only : rk => real64 implicit none real ( rk ), dimension (:), allocatable :: y print * , \" \" print * , \"Running example...\" #if defined (NOPURE_DEBUG) ! No pure debug #else call pure_subroutine ( 1 0.0_rk , 7 , y ) #endif #if defined (NOPURE_DEBUG) ! No pure debug #else contains pure subroutine pure_subroutine ( x , n , y ) use fordebug , only : timer , pwrite , ptimer_start , ptimer_stop implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'example/example_p.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) do concurrent ( i = 2 : n ) y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'example/example_p.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'example/example_p.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'example/example_p.txt' , access = 'append' ) end subroutine pure_subroutine #endif end program example_p","tags":"","url":"sourcefile/example_p.f90.html"},{"title":"fordebug.F90 – ForDebug","text":"Files dependent on this one sourcefile~~fordebug.f90~~AfferentGraph sourcefile~fordebug.f90 fordebug.F90 sourcefile~ewic_complex.f90 ewic_complex.F90 sourcefile~ewic_complex.f90->sourcefile~fordebug.f90 sourcefile~ewic_simple.f90 ewic_simple.f90 sourcefile~ewic_simple.f90->sourcefile~fordebug.f90 sourcefile~example_p.f90 example_p.F90 sourcefile~example_p.f90->sourcefile~fordebug.f90 sourcefile~fordebug_smod.f90 fordebug_smod.F90 sourcefile~fordebug_smod.f90->sourcefile~fordebug.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module fordebug use iso_fortran_env , only : int32 , int64 , real32 , real64 use fortime , only : timer implicit none private #if defined (NOPURE_DEBUG) ! No pure debug public debug , debug_loc #else public pwrite , timer , ptimer_start , ptimer_stop , debug , debug_loc #endif #if defined(FOR_DEBUG) logical , parameter , private :: DEBUG_MODE = . true . #else logical , parameter , private :: DEBUG_MODE = . false . #endif integer , parameter , private :: NONE = 0 integer , parameter , private :: ERROR = 1 integer , parameter , private :: WARNING = 2 integer , parameter , private :: INFO = 3 integer , parameter , private :: MAX_LENGTH_CATEGORY = 32 integer , parameter , private :: MAX_LENGTH_MESSAGE = 128 integer , parameter , private :: MAX_LENGTH_LOCATION = 128 integer , parameter , private :: MAX_LENGTH_SUGGESTION = 128 !=============================================================================== type debug logical , private :: dbg = DEBUG_MODE !! debug mode flag logical :: ok = . true . !! .true. means no error/warning/info integer , private :: code = NONE !! error/warning/info code, 0=none integer , private :: severity = NONE !! severity of the error, 0=none, 1=error, 2=warning, 3=info character ( MAX_LENGTH_CATEGORY ), private :: category !! category of error/warning/info character ( MAX_LENGTH_LOCATION ), private :: location !! location of error/warning/info character ( MAX_LENGTH_MESSAGE ), private :: message !! message of error/warning/info character ( MAX_LENGTH_SUGGESTION ), private :: suggestion !! suggestion for error/warning/info contains procedure :: set procedure :: print => print_error procedure :: reset end type debug !=============================================================================== #if defined (NOPURE_DEBUG) ! No pure debug #else interface !=============================================================================== !> author: Seyed Ali Ghasemi pure module subroutine pwrite (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) implicit none character ( * ), intent ( in ), optional :: message !! Message to print character ( * ), intent ( in ), optional :: file !! File to write to character ( * ), intent ( in ), optional :: format !! Format to use for printing character ( * ), intent ( in ), optional :: R0ch !! Rank=0, character integer ( int32 ), intent ( in ), optional :: R0i32 !! Rank=0, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R0i64 !! Rank=0, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R0r32 !! Rank=0, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R0r64 !! Rank=0, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R0c32 !! Rank=0, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R0c64 !! Rank=0, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R1i32 (:) !! Rank=1, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R1i64 (:) !! Rank=1, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R1r32 (:) !! Rank=1, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R1r64 (:) !! Rank=1, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R1c32 (:) !! Rank=1, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R1c64 (:) !! Rank=1, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R2i32 (:,:) !! Rank=2, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R2i64 (:,:) !! Rank=2, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R2r32 (:,:) !! Rank=2, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R2r64 (:,:) !! Rank=2, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R2c32 (:,:) !! Rank=2, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R2c64 (:,:) !! Rank=2, complex, kind=real64 character ( * ), intent ( in ), optional :: access !! Access mode for file end subroutine pwrite !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure module subroutine ptimer_start ( t ) implicit none type ( timer ), intent ( inout ) :: t end subroutine ptimer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure module subroutine ptimer_stop ( t , message ) implicit none type ( timer ), intent ( inout ) :: t character ( len =* ), intent ( in ), optional :: message end subroutine ptimer_stop !=============================================================================== end interface #endif contains !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure elemental subroutine set ( this , severity , code , category , message , location , suggestion ) class ( debug ), intent ( inout ) :: this integer , intent ( in ) :: severity integer , intent ( in ) :: code character ( len =* ), intent ( in ) :: category character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: location character ( len =* ), intent ( in ) :: suggestion if ( this % dbg ) then if ( severity /= NONE . and . severity /= ERROR . and . severity /= WARNING . and . severity /= INFO ) error stop \"Invalid severity level\" this % severity = severity this % code = code if ( this % code /= NONE . or . this % severity /= NONE ) this % ok = . false . this % category = trim ( category ) this % message = trim ( message ) this % suggestion = trim ( suggestion ) this % location = trim ( location ) end if end subroutine set !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure function debug_loc ( file , line ) result ( s ) character ( * ), intent ( in ) :: file integer , intent ( in ) :: line character ( len = 256 ) :: s write ( s , '(a,\":\",i0)' ) trim ( file ), line end function debug_loc !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause impure subroutine print_error ( this ) class ( debug ), intent ( in ) :: this character ( len = 1 ) :: sev_letter character ( len =* ), parameter :: & ESC = char ( 27 ), & RED = ESC // \"[31m\" , & YEL = ESC // \"[33m\" , & BLU = ESC // \"[34m\" , & GRY = ESC // \"[90m\" , & RST = ESC // \"[0m\" character ( len = 5 ) :: color character ( len = 20 ) :: code_str character (:), allocatable :: line if ( this % dbg . and . . not . this % ok ) then select case ( this % severity ) case ( ERROR ); sev_letter = 'E' ; color = RED case ( WARNING ); sev_letter = 'W' ; color = YEL case ( INFO ); sev_letter = 'I' ; color = BLU case default ; sev_letter = 'N' ; color = GRY end select write ( code_str , '(i0)' ) this % code line = color // '[' // sev_letter // trim ( code_str ) // ']' // RST // ' ' // & '(' // GRY // trim ( this % location ) // RST // ') ' // & trim ( this % category ) // ': ' // & trim ( this % message ) if ( len_trim ( this % suggestion ) > 0 ) then line = line // ' [' // trim ( this % suggestion ) // ']' end if write ( * , '(a)' ) trim ( line ) end if end subroutine print_error !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> license: BSD 3-Clause pure elemental subroutine reset ( this ) class ( debug ), intent ( inout ) :: this this % dbg = DEBUG_MODE this % ok = . true . this % code = NONE this % severity = NONE this % category = \"\" this % message = \"\" this % location = \"\" this % suggestion = \"\" end subroutine reset !=============================================================================== end module fordebug","tags":"","url":"sourcefile/fordebug.f90.html"},{"title":"ewic_complex.F90 – ForDebug","text":"This file depends on sourcefile~~ewic_complex.f90~~EfferentGraph sourcefile~ewic_complex.f90 ewic_complex.F90 sourcefile~fordebug.f90 fordebug.F90 sourcefile~ewic_complex.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module my_module use fordebug , only : debug , debug_loc implicit none private public my_type type my_type integer :: a , b type ( debug ) :: err contains procedure :: my_function procedure :: my_subroutine end type my_type contains pure function my_function ( this , a ) result ( b ) class ( my_type ), intent ( in ) :: this integer , intent ( in ) :: a integer :: b #if defined(FOR_DEBUG) if (. not . this % err % ok ) then b = 0 return end if #endif b = 2 / a end function my_function pure subroutine my_subroutine ( this , a ) class ( my_type ), intent ( inout ) :: this integer , intent ( in ) :: a #if defined(FOR_DEBUG) if (. not . this % err % ok ) return if ( a == 0 ) then call this % err % set ( 1 , 100 , \"arithmetic/zero-division\" , \"Division by zero, denominator a = 0\" , debug_loc ( __ FILE__ , 26 ), \"Enforce precondition a /= 0\" ) return end if #endif this % b = this % my_function ( a ) end subroutine my_subroutine end module my_module program complex use my_module , only : my_type implicit none type ( my_type ) :: obj print * , \" \" print * , \"Running complex example...\" call obj % my_subroutine ( 0 ) call obj % err % print () end program complex","tags":"","url":"sourcefile/ewic_complex.f90.html"},{"title":"fordebug_smod.F90 – ForDebug","text":"This file depends on sourcefile~~fordebug_smod.f90~~EfferentGraph sourcefile~fordebug_smod.f90 fordebug_smod.F90 sourcefile~fordebug.f90 fordebug.F90 sourcefile~fordebug_smod.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code #ifndef NOPURE_DEBUG submodule ( fordebug ) fordebug_smod implicit none interface !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) import int32 , int64 , real32 , real64 implicit none character ( * ), intent ( in ), optional :: message !! Message to print character ( * ), intent ( in ), optional :: file !! File to write to character ( * ), intent ( in ), optional :: format !! Format to use for printing character ( * ), intent ( in ), optional :: R0ch !! Rank=0, character integer ( int32 ), intent ( in ), optional :: R0i32 !! Rank=0, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R0i64 !! Rank=0, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R0r32 !! Rank=0, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R0r64 !! Rank=0, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R0c32 !! Rank=0, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R0c64 !! Rank=0, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R1i32 (:) !! Rank=1, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R1i64 (:) !! Rank=1, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R1r32 (:) !! Rank=1, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R1r64 (:) !! Rank=1, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R1c32 (:) !! Rank=1, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R1c64 (:) !! Rank=1, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R2i32 (:,:) !! Rank=2, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R2i64 (:,:) !! Rank=2, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R2r32 (:,:) !! Rank=2, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R2r64 (:,:) !! Rank=2, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R2c32 (:,:) !! Rank=2, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R2c64 (:,:) !! Rank=2, complex, kind=real64 character ( * ), intent ( in ), optional :: access !! Access mode for file end subroutine impure_write !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine impure_timer_start ( t ) import timer implicit none type ( timer ), intent ( inout ) :: t end subroutine impure_timer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine impure_timer_stop ( t , message ) import timer implicit none type ( timer ), intent ( inout ) :: t character ( len =* ), intent ( in ), optional :: message end subroutine impure_timer_stop !=============================================================================== end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi module procedure pwrite call impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) end procedure pwrite !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi module procedure ptimer_start call impure_timer_start ( t ) end procedure ptimer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi module procedure ptimer_stop call impure_timer_stop ( t , message ) end procedure ptimer_stop !=============================================================================== end submodule fordebug_smod #endif #ifndef NOPURE_DEBUG !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) use iso_fortran_env , only : int32 , int64 , real32 , real64 implicit none character ( * ), intent ( in ), optional :: message !! Message to print character ( * ), intent ( in ), optional :: file !! File to write to character ( * ), intent ( in ), optional :: format !! Format to use for printing character ( * ), intent ( in ), optional :: R0ch !! Rank=0, character integer ( int32 ), intent ( in ), optional :: R0i32 !! Rank=0, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R0i64 !! Rank=0, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R0r32 !! Rank=0, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R0r64 !! Rank=0, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R0c32 !! Rank=0, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R0c64 !! Rank=0, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R1i32 (:) !! Rank=1, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R1i64 (:) !! Rank=1, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R1r32 (:) !! Rank=1, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R1r64 (:) !! Rank=1, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R1c32 (:) !! Rank=1, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R1c64 (:) !! Rank=1, complex, kind=real64 integer ( int32 ), intent ( in ), optional :: R2i32 (:,:) !! Rank=2, integer, kind=int32 integer ( int64 ), intent ( in ), optional :: R2i64 (:,:) !! Rank=2, integer, kind=int64 real ( real32 ), intent ( in ), optional :: R2r32 (:,:) !! Rank=2, real   , kind=real32 real ( real64 ), intent ( in ), optional :: R2r64 (:,:) !! Rank=2, real   , kind=real64 complex ( real32 ), intent ( in ), optional :: R2c32 (:,:) !! Rank=2, complex, kind=real32 complex ( real64 ), intent ( in ), optional :: R2c64 (:,:) !! Rank=2, complex, kind=real64 character ( * ), intent ( in ), optional :: access !! Access mode for file integer :: nunit !! Unit number ! Open the file if it was specified if ( present ( file )) then if ( present ( access )) then open ( newunit = nunit , file = trim ( file ), access = access , action = 'write' ) else open ( newunit = nunit , file = trim ( file ), action = 'write' ) end if end if !=================================================== ! Write optional rank 0 variables !=================================================== ! Write optional rank 0 character variables if ( present ( R0ch )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0ch else write ( nunit , * ) message , R0ch end if else if ( present ( format )) then write ( nunit , format ) R0ch else write ( nunit , * ) R0ch end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0ch else write ( * , * ) message , R0ch end if else if ( present ( format )) then write ( * , format ) R0ch else write ( * , * ) R0ch end if end if end if end if ! Write optional rank 0 integer variables if ( present ( R0i32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0i32 else write ( nunit , * ) message , R0i32 end if else if ( present ( format )) then write ( nunit , format ) R0i32 else write ( nunit , * ) R0i32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0i32 else write ( * , * ) message , R0i32 end if else if ( present ( format )) then write ( * , format ) R0i32 else write ( * , * ) R0i32 end if end if end if end if ! Write optional rank 0 integer variables if ( present ( R0i64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0i64 else write ( nunit , * ) message , R0i64 end if else if ( present ( format )) then write ( nunit , format ) R0i64 else write ( nunit , * ) R0i64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0i64 else write ( * , * ) message , R0i64 end if else if ( present ( format )) then write ( * , format ) R0i64 else write ( * , * ) R0i64 end if end if end if end if ! Write optional rank 0 real variables if ( present ( R0r32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0r32 else write ( nunit , * ) message , R0r32 end if else if ( present ( format )) then write ( nunit , format ) R0r32 else write ( nunit , * ) R0r32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0r32 else write ( * , * ) message , R0r32 end if else if ( present ( format )) then write ( * , format ) R0r32 else write ( * , * ) R0r32 end if end if end if end if ! Write optional rank 0 real variables if ( present ( R0r64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0r64 else write ( nunit , * ) message , R0r64 end if else if ( present ( format )) then write ( nunit , format ) R0r64 else write ( nunit , * ) R0r64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0r64 else write ( * , * ) message , R0r64 end if else if ( present ( format )) then write ( * , format ) R0r64 else write ( * , * ) R0r64 end if end if end if end if ! Write optional rank 0 complex variables if ( present ( R0c32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0c32 else write ( nunit , * ) message , R0c32 end if else if ( present ( format )) then write ( nunit , format ) R0c32 else write ( nunit , * ) R0c32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0c32 else write ( * , * ) message , R0c32 end if else if ( present ( format )) then write ( * , format ) R0c32 else write ( * , * ) R0c32 end if end if end if end if ! Write optional rank 0 complex variables if ( present ( R0c64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0c64 else write ( nunit , * ) message , R0c64 end if else if ( present ( format )) then write ( nunit , format ) R0c64 else write ( nunit , * ) R0c64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0c64 else write ( * , * ) message , R0c64 end if else if ( present ( format )) then write ( * , format ) R0c64 else write ( * , * ) R0c64 end if end if end if end if !=================================================== ! Write optional rank 1 arrays !=================================================== ! Write optional rank 1 integer arrays if ( present ( R1i32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1i32 else write ( nunit , * ) message , R1i32 end if else if ( present ( format )) then write ( nunit , format ) R1i32 else write ( nunit , * ) R1i32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1i32 else write ( * , * ) message , R1i32 end if else if ( present ( format )) then write ( * , format ) R1i32 else write ( * , * ) R1i32 end if end if end if end if ! Write optional rank 1 integer arrays if ( present ( R1i64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1i64 else write ( nunit , * ) message , R1i64 end if else if ( present ( format )) then write ( nunit , format ) R1i64 else write ( nunit , * ) R1i64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1i64 else write ( * , * ) message , R1i64 end if else if ( present ( format )) then write ( * , format ) R1i64 else write ( * , * ) R1i64 end if end if end if end if ! Write optional rank 1 real arrays if ( present ( R1r32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1r32 else write ( nunit , * ) message , R1r32 end if else if ( present ( format )) then write ( nunit , format ) R1r32 else write ( nunit , * ) R1r32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1r32 else write ( * , * ) message , R1r32 end if else if ( present ( format )) then write ( * , format ) R1r32 else write ( * , * ) R1r32 end if end if end if end if ! Write optional rank 1 real arrays if ( present ( R1r64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1r64 else write ( nunit , * ) message , R1r64 end if else if ( present ( format )) then write ( nunit , format ) R1r64 else write ( nunit , * ) R1r64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1r64 else write ( * , * ) message , R1r64 end if else if ( present ( format )) then write ( * , format ) R1r64 else write ( * , * ) R1r64 end if end if end if end if ! Write optional rank 1 complex arrays if ( present ( R1c32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1c32 else write ( nunit , * ) message , R1c32 end if else if ( present ( format )) then write ( nunit , format ) R1c32 else write ( nunit , * ) R1c32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1c32 else write ( * , * ) message , R1c32 end if else if ( present ( format )) then write ( * , format ) R1c32 else write ( * , * ) R1c32 end if end if end if end if ! Write optional rank 1 complex arrays if ( present ( R1c64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1c64 else write ( nunit , * ) message , R1c64 end if else if ( present ( format )) then write ( nunit , format ) R1c64 else write ( nunit , * ) R1c64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1c64 else write ( * , * ) message , R1c64 end if else if ( present ( format )) then write ( * , format ) R1c64 else write ( * , * ) R1c64 end if end if end if end if !=================================================== ! Write optional rank 2 arrays !=================================================== ! Write optional rank 2 integer arrays if ( present ( R2i32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2i32 else write ( nunit , * ) message , R2i32 end if else if ( present ( format )) then write ( nunit , format ) R2i32 else write ( nunit , * ) R2i32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2i32 else write ( * , * ) message , R2i32 end if else if ( present ( format )) then write ( * , format ) R2i32 else write ( * , * ) R2i32 end if end if end if end if ! Write optional rank 2 integer arrays if ( present ( R2i64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2i64 else write ( nunit , * ) message , R2i64 end if else if ( present ( format )) then write ( nunit , format ) R2i64 else write ( nunit , * ) R2i64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2i64 else write ( * , * ) message , R2i64 end if else if ( present ( format )) then write ( * , format ) R2i64 else write ( * , * ) R2i64 end if end if end if end if ! Write optional rank 2 real arrays if ( present ( R2r32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2r32 else write ( nunit , * ) message , R2r32 end if else if ( present ( format )) then write ( nunit , format ) R2r32 else write ( nunit , * ) R2r32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2r32 else write ( * , * ) message , R2r32 end if else if ( present ( format )) then write ( * , format ) R2r32 else write ( * , * ) R2r32 end if end if end if end if ! Write optional rank 2 real arrays if ( present ( R2r64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2r64 else write ( nunit , * ) message , R2r64 end if else if ( present ( format )) then write ( nunit , format ) R2r64 else write ( nunit , * ) R2r64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2r64 else write ( * , * ) message , R2r64 end if else if ( present ( format )) then write ( * , format ) R2r64 else write ( * , * ) R2r64 end if end if end if end if ! Write optional rank 2 complex arrays if ( present ( R2c32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2c32 else write ( nunit , * ) message , R2c32 end if else if ( present ( format )) then write ( nunit , format ) R2c32 else write ( nunit , * ) R2c32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2c32 else write ( * , * ) message , R2c32 end if else if ( present ( format )) then write ( * , format ) R2c32 else write ( * , * ) R2c32 end if end if end if end if ! Write optional rank 2 complex arrays if ( present ( R2c64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2c64 else write ( nunit , * ) message , R2c64 end if else if ( present ( format )) then write ( nunit , format ) R2c64 else write ( nunit , * ) R2c64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2c64 else write ( * , * ) message , R2c64 end if else if ( present ( format )) then write ( * , format ) R2c64 else write ( * , * ) R2c64 end if end if end if end if ! Close the file if it was opened if ( present ( file )) close ( nunit ) end subroutine impure_write !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine impure_timer_start ( t ) use fortime , only : timer implicit none type ( timer ), intent ( inout ) :: t call t % timer_start () end subroutine impure_timer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine impure_timer_stop ( t , message ) use fortime , only : timer implicit none type ( timer ), intent ( inout ) :: t character ( * ), intent ( in ), optional :: message call t % timer_stop ( message = message ) end subroutine impure_timer_stop !=============================================================================== #endif","tags":"","url":"sourcefile/fordebug_smod.f90.html"},{"title":"ewic_simple.f90 – ForDebug","text":"This file depends on sourcefile~~ewic_simple.f90~~EfferentGraph sourcefile~ewic_simple.f90 ewic_simple.f90 sourcefile~fordebug.f90 fordebug.F90 sourcefile~ewic_simple.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program simple use fordebug , only : debug , debug_loc implicit none type ( debug ) :: err print * , \" \" print * , \"Running simple example...\" ! Info: starting a numerical solve call err % set (& severity = 3 , & code = 10 , & category = \"initialization\" , & message = \"Starting Cholesky factorization\" , & location = debug_loc ( __ FILE__ , 9 ), & suggestion = \"Proceed; this is a standard setup step.\" ) call err % print () ! Warning: potential numerical issue call err % set (& severity = 2 , & code = 20 , & category = \"numerical-warning\" , & message = \"Matrix is not positive definite\" , & location = \"simple.f90:18\" , & suggestion = \"Check matrix symmetry and eigenvalues before factorization.\" ) call err % print () ! Error: hard failure call err % set (& severity = 1 , & code = 30 , & category = \"arithmetic-error\" , & message = \"Division by zero detected in pivot step\" , & location = \"simple.f90:27\" , & suggestion = \"Ensure pivot elements are nonzero; consider partial pivoting.\" ) call err % print () call err % reset () end program simple","tags":"","url":"sourcefile/ewic_simple.f90.html"}]}