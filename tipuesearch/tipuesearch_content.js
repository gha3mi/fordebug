var tipuesearch = {"pages":[{"title":" ForDebug ","text":"ForDebug ForDebug : A Fortran library designed for debugging Fortran code, especially within pure procedures. USE OF THIS LIBRARY IS NOT STANDARDS CONFORMING AND YOU CAN EXPECT THINGS TO BREAK IN PLENTY OF SITUATIONS. IT SHOULD BE USED ONLY FOR DEBUGGING PURPOSES fpm dependency How to run demo API documentation Contributing fpm dependency If you want to use ForDebug as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] fordebug = { git = \"https://github.com/gha3mi/fordebug.git\" } Usage Printing or Writing within Pure Procedures To enable printing or writing within a pure procedure in Fortran, use the fordebug module. use fordebug ! within pure procedures call pwrite ( message = 'hello!' ) call pwrite ( R0i32 = n ) call pwrite ( message = 'x = ' , R0r32 = 1 0.0 , format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) Notes All arguments of pwrite are optional. Data types are represented using the following conventions: R0i32 , R0i64 , R0r32 , R0r64 , R0c32 , R0c64 for Rank 0 integer, real, and complex types. R1i32 , R1i64 , R1r32 , R1r64 , R1c32 , R1c64 for Rank 1 integer, real, and complex types. R2i32 , R2i64 , R2r32 , R2r64 , R2c32 , R2c64 for Rank 2 integer, real, and complex types. R0ch for Rank 0 character. Measuring Elapsed Time within Pure Procedures ForDebug uses ForTmie as dependency. For measuring elapsed time within a pure procedure, utilize the fordebug module with time derived type. use fordebug type ( timer ) :: t call ptimer_start ( t ) ! Perform your operations here call ptimer_stop ( t ) ! Output: Elapsed time:  0.000 [s] How to run demo Clone the repository: Clone the ForDebug repository from GitHub using the following command: git clone https://github.com/gha3mi/fordebug.git Navigate to the cloned directory: cd fordebug Running demo To run demo , execute the following command: fpm run --example demo API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForDebug using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForDebug are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Acknowledgment This project draws inspiration from https://github.com/plevold/fortran-debug-utils. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"impure_write – ForDebug","text":"subroutine impure_write(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Uses iso_fortran_env proc~~impure_write~~UsesGraph proc~impure_write impure_write iso_fortran_env iso_fortran_env proc~impure_write->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file Source Code pure subroutine impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) import int32 , int64 , real32 , real64 include 'pwrite.inc' end subroutine impure_write","tags":"","loc":"proc/impure_write.html"},{"title":"impure_timer_start – ForDebug","text":"subroutine impure_timer_start(t) Uses fortime proc~~impure_timer_start~~UsesGraph proc~impure_timer_start impure_timer_start fortime fortime proc~impure_timer_start->fortime Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t Calls proc~~impure_timer_start~~CallsGraph proc~impure_timer_start impure_timer_start timer_start timer_start proc~impure_timer_start->timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine impure_timer_start ( t ) import timer type ( timer ), intent ( out ) :: t end subroutine impure_timer_start","tags":"","loc":"proc/impure_timer_start.html"},{"title":"impure_timer_stop – ForDebug","text":"subroutine impure_timer_stop(t, message) Uses fortime proc~~impure_timer_stop~~UsesGraph proc~impure_timer_stop impure_timer_stop fortime fortime proc~impure_timer_stop->fortime Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t character(len=*), intent(in), optional :: message Calls proc~~impure_timer_stop~~CallsGraph proc~impure_timer_stop impure_timer_stop timer_stop timer_stop proc~impure_timer_stop->timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine impure_timer_stop ( t , message ) import timer type ( timer ), intent ( out ) :: t character ( len =* ), intent ( in ), optional :: message end subroutine impure_timer_stop","tags":"","loc":"proc/impure_timer_stop.html"},{"title":"impure_write – ForDebug","text":"interface Called by interface~~impure_write~~CalledByGraph interface~impure_write impure_write proc~pwrite pwrite proc~pwrite->interface~impure_write Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. pure subroutine impure_write(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file","tags":"","loc":"interface/impure_write.html"},{"title":"impure_timer_start – ForDebug","text":"interface Called by interface~~impure_timer_start~~CalledByGraph interface~impure_timer_start impure_timer_start proc~ptimer_start ptimer_start proc~ptimer_start->interface~impure_timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. pure subroutine impure_timer_start(t) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t","tags":"","loc":"interface/impure_timer_start.html"},{"title":"impure_timer_stop – ForDebug","text":"interface Called by interface~~impure_timer_stop~~CalledByGraph interface~impure_timer_stop impure_timer_stop proc~ptimer_stop ptimer_stop proc~ptimer_stop->interface~impure_timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. pure subroutine impure_timer_stop(t, message) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t character(len=*), intent(in), optional :: message","tags":"","loc":"interface/impure_timer_stop.html"},{"title":"pwrite – ForDebug","text":"interface Called by interface~~pwrite~~CalledByGraph interface~pwrite pwrite proc~pure_subroutine pure_subroutine proc~pure_subroutine->interface~pwrite program~demo demo program~demo->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file","tags":"","loc":"interface/pwrite.html"},{"title":"ptimer_start – ForDebug","text":"interface Called by interface~~ptimer_start~~CalledByGraph interface~ptimer_start ptimer_start proc~pure_subroutine pure_subroutine proc~pure_subroutine->interface~ptimer_start program~demo demo program~demo->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public pure module subroutine ptimer_start(t) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t","tags":"","loc":"interface/ptimer_start.html"},{"title":"ptimer_stop – ForDebug","text":"interface Called by interface~~ptimer_stop~~CalledByGraph interface~ptimer_stop ptimer_stop proc~pure_subroutine pure_subroutine proc~pure_subroutine->interface~ptimer_stop program~demo demo program~demo->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public pure module subroutine ptimer_stop(t, message) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t character(len=*), intent(in), optional :: message","tags":"","loc":"interface/ptimer_stop.html"},{"title":"pure_subroutine – ForDebug","text":"pure subroutine pure_subroutine(x, n, y) Uses fordebug proc~~pure_subroutine~~UsesGraph proc~pure_subroutine pure_subroutine module~fordebug fordebug proc~pure_subroutine->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x integer, intent(in) :: n real(kind=rk), intent(out), allocatable :: y (:) Calls proc~~pure_subroutine~~CallsGraph proc~pure_subroutine pure_subroutine interface~ptimer_start ptimer_start proc~pure_subroutine->interface~ptimer_start interface~ptimer_stop ptimer_stop proc~pure_subroutine->interface~ptimer_stop interface~pwrite pwrite proc~pure_subroutine->interface~pwrite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pure_subroutine~~CalledByGraph proc~pure_subroutine pure_subroutine program~demo demo program~demo->proc~pure_subroutine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine pure_subroutine ( x , n , y ) use fordebug implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'example/demo.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) do concurrent ( i = 2 : n ) y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'example/demo.txt' , access = 'append' ) end subroutine pure_subroutine","tags":"","loc":"proc/pure_subroutine.html"},{"title":"pwrite – ForDebug","text":"module procedure pwrite pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Interface → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file Calls proc~~pwrite~~CallsGraph proc~pwrite pwrite interface~impure_write impure_write proc~pwrite->interface~impure_write Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/pwrite.html"},{"title":"ptimer_start – ForDebug","text":"module procedure ptimer_start pure module subroutine ptimer_start(t) Interface → Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t Calls proc~~ptimer_start~~CallsGraph proc~ptimer_start ptimer_start interface~impure_timer_start impure_timer_start proc~ptimer_start->interface~impure_timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ptimer_start.html"},{"title":"ptimer_stop – ForDebug","text":"module procedure ptimer_stop pure module subroutine ptimer_stop(t, message) Interface → Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t character(len=*), intent(in), optional :: message Calls proc~~ptimer_stop~~CallsGraph proc~ptimer_stop ptimer_stop interface~impure_timer_stop impure_timer_stop proc~ptimer_stop->interface~impure_timer_stop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/ptimer_stop.html"},{"title":"fordebug – ForDebug","text":"Uses fortime iso_fortran_env module~~fordebug~~UsesGraph module~fordebug fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: fordebug_smod module~~fordebug~~UsedByGraph module~fordebug fordebug module~fordebug_smod fordebug_smod module~fordebug_smod->module~fordebug proc~pure_subroutine pure_subroutine proc~pure_subroutine->module~fordebug Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface public pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file interface public pure module subroutine ptimer_start(t) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t interface public pure module subroutine ptimer_stop(t, message) Implementation → Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t character(len=*), intent(in), optional :: message","tags":"","loc":"module/fordebug.html"},{"title":"fordebug_smod – ForDebug","text":"Uses Ancestors: fordebug module~~fordebug_smod~~UsesGraph module~fordebug_smod fordebug_smod module~fordebug fordebug module~fordebug_smod->module~fordebug fortime fortime module~fordebug->fortime iso_fortran_env iso_fortran_env module~fordebug->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface pure subroutine impure_write(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file interface pure subroutine impure_timer_start(t) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t interface pure subroutine impure_timer_stop(t, message) Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t character(len=*), intent(in), optional :: message Module Procedures module procedure /home/runner/work/fordebug/fordebug/doc/module/fordebug_smod.html pwrite pure module subroutine pwrite(message, format, file, R0i32, R0r32, R0c32, R0i64, R0r64, R0c64, R0ch, R1i32, R1r32, R1c32, R1i64, R1r64, R1c64, R2i32, R2r32, R2c32, R2i64, R2r64, R2c64, access) Interface → Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: message Message to print character(len=*), intent(in), optional :: format Format to use for printing character(len=*), intent(in), optional :: file File to write to integer(kind=int32), intent(in), optional :: R0i32 Rank=0, integer, kind=int32 real(kind=real32), intent(in), optional :: R0r32 Rank=0, real   , kind=real32 complex(kind=real32), intent(in), optional :: R0c32 Rank=0, complex, kind=real32 integer(kind=int64), intent(in), optional :: R0i64 Rank=0, integer, kind=int64 real(kind=real64), intent(in), optional :: R0r64 Rank=0, real   , kind=real64 complex(kind=real64), intent(in), optional :: R0c64 Rank=0, complex, kind=real64 character(len=*), intent(in), optional :: R0ch Rank=0, character integer(kind=int32), intent(in), optional :: R1i32 (:) Rank=1, integer, kind=int32 real(kind=real32), intent(in), optional :: R1r32 (:) Rank=1, real   , kind=real32 complex(kind=real32), intent(in), optional :: R1c32 (:) Rank=1, complex, kind=real32 integer(kind=int64), intent(in), optional :: R1i64 (:) Rank=1, integer, kind=int64 real(kind=real64), intent(in), optional :: R1r64 (:) Rank=1, real   , kind=real64 complex(kind=real64), intent(in), optional :: R1c64 (:) Rank=1, complex, kind=real64 integer(kind=int32), intent(in), optional :: R2i32 (:,:) Rank=2, integer, kind=int32 real(kind=real32), intent(in), optional :: R2r32 (:,:) Rank=2, real   , kind=real32 complex(kind=real32), intent(in), optional :: R2c32 (:,:) Rank=2, complex, kind=real32 integer(kind=int64), intent(in), optional :: R2i64 (:,:) Rank=2, integer, kind=int64 real(kind=real64), intent(in), optional :: R2r64 (:,:) Rank=2, real   , kind=real64 complex(kind=real64), intent(in), optional :: R2c64 (:,:) Rank=2, complex, kind=real64 character(len=*), intent(in), optional :: access Access mode for file module procedure /home/runner/work/fordebug/fordebug/doc/module/fordebug_smod.html ptimer_start pure module subroutine ptimer_start(t) Interface → Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t module procedure /home/runner/work/fordebug/fordebug/doc/module/fordebug_smod.html ptimer_stop pure module subroutine ptimer_stop(t, message) Interface → Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name type(timer), intent(out) :: t character(len=*), intent(in), optional :: message","tags":"","loc":"module/fordebug_smod.html"},{"title":"demo – ForDebug","text":"Uses iso_fortran_env program~~demo~~UsesGraph program~demo demo iso_fortran_env iso_fortran_env program~demo->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~demo~~CallsGraph program~demo demo proc~pure_subroutine pure_subroutine program~demo->proc~pure_subroutine interface~ptimer_start ptimer_start proc~pure_subroutine->interface~ptimer_start interface~ptimer_stop ptimer_stop proc~pure_subroutine->interface~ptimer_stop interface~pwrite pwrite proc~pure_subroutine->interface~pwrite Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:), allocatable :: y Subroutines pure subroutine pure_subroutine (x, n, y) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: x integer, intent(in) :: n real(kind=rk), intent(out), allocatable :: y (:) Source Code program demo use iso_fortran_env , only : rk => real64 implicit none real ( rk ), dimension (:), allocatable :: y call pure_subroutine ( 1 0.0_rk , 7 , y ) contains pure subroutine pure_subroutine ( x , n , y ) use fordebug implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'example/demo.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) do concurrent ( i = 2 : n ) y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'example/demo.txt' , access = 'append' ) end subroutine pure_subroutine end program demo","tags":"","loc":"program/demo.html"},{"title":"fordebug_smod.f90 – ForDebug","text":"This file depends on sourcefile~~fordebug_smod.f90~~EfferentGraph sourcefile~fordebug_smod.f90 fordebug_smod.f90 sourcefile~fordebug.f90 fordebug.f90 sourcefile~fordebug_smod.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( fordebug ) fordebug_smod implicit none interface !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) import int32 , int64 , real32 , real64 include 'pwrite.inc' end subroutine impure_write !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine impure_timer_start ( t ) import timer type ( timer ), intent ( out ) :: t end subroutine impure_timer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine impure_timer_stop ( t , message ) import timer type ( timer ), intent ( out ) :: t character ( len =* ), intent ( in ), optional :: message end subroutine impure_timer_stop !=============================================================================== end interface contains !=============================================================================== !> author: Seyed Ali Ghasemi module procedure pwrite call impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) end procedure pwrite !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi module procedure ptimer_start call impure_timer_start ( t ) end procedure ptimer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi module procedure ptimer_stop call impure_timer_stop ( t , message ) end procedure ptimer_stop !=============================================================================== end submodule fordebug_smod !=============================================================================== !> author: Seyed Ali Ghasemi subroutine impure_write (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) use iso_fortran_env , only : int32 , int64 , real32 , real64 implicit none include 'pwrite.inc' integer :: nunit !! Unit number ! Open the file if it was specified if ( present ( file )) then if ( present ( access )) then open ( newunit = nunit , file = trim ( file ), access = access , action = 'write' ) else open ( newunit = nunit , file = trim ( file ), action = 'write' ) end if end if !=================================================== ! Write optional rank 0 variables !=================================================== ! Write optional rank 0 character variables if ( present ( R0ch )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0ch else write ( nunit , * ) message , R0ch end if else if ( present ( format )) then write ( nunit , format ) R0ch else write ( nunit , * ) R0ch end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0ch else write ( * , * ) message , R0ch end if else if ( present ( format )) then write ( * , format ) R0ch else write ( * , * ) R0ch end if end if end if end if ! Write optional rank 0 integer variables if ( present ( R0i32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0i32 else write ( nunit , * ) message , R0i32 end if else if ( present ( format )) then write ( nunit , format ) R0i32 else write ( nunit , * ) R0i32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0i32 else write ( * , * ) message , R0i32 end if else if ( present ( format )) then write ( * , format ) R0i32 else write ( * , * ) R0i32 end if end if end if end if ! Write optional rank 0 integer variables if ( present ( R0i64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0i64 else write ( nunit , * ) message , R0i64 end if else if ( present ( format )) then write ( nunit , format ) R0i64 else write ( nunit , * ) R0i64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0i64 else write ( * , * ) message , R0i64 end if else if ( present ( format )) then write ( * , format ) R0i64 else write ( * , * ) R0i64 end if end if end if end if ! Write optional rank 0 real variables if ( present ( R0r32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0r32 else write ( nunit , * ) message , R0r32 end if else if ( present ( format )) then write ( nunit , format ) R0r32 else write ( nunit , * ) R0r32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0r32 else write ( * , * ) message , R0r32 end if else if ( present ( format )) then write ( * , format ) R0r32 else write ( * , * ) R0r32 end if end if end if end if ! Write optional rank 0 real variables if ( present ( R0r64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0r64 else write ( nunit , * ) message , R0r64 end if else if ( present ( format )) then write ( nunit , format ) R0r64 else write ( nunit , * ) R0r64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0r64 else write ( * , * ) message , R0r64 end if else if ( present ( format )) then write ( * , format ) R0r64 else write ( * , * ) R0r64 end if end if end if end if ! Write optional rank 0 complex variables if ( present ( R0c32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0c32 else write ( nunit , * ) message , R0c32 end if else if ( present ( format )) then write ( nunit , format ) R0c32 else write ( nunit , * ) R0c32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0c32 else write ( * , * ) message , R0c32 end if else if ( present ( format )) then write ( * , format ) R0c32 else write ( * , * ) R0c32 end if end if end if end if ! Write optional rank 0 complex variables if ( present ( R0c64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R0c64 else write ( nunit , * ) message , R0c64 end if else if ( present ( format )) then write ( nunit , format ) R0c64 else write ( nunit , * ) R0c64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R0c64 else write ( * , * ) message , R0c64 end if else if ( present ( format )) then write ( * , format ) R0c64 else write ( * , * ) R0c64 end if end if end if end if !=================================================== ! Write optional rank 1 arrays !=================================================== ! Write optional rank 1 integer arrays if ( present ( R1i32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1i32 else write ( nunit , * ) message , R1i32 end if else if ( present ( format )) then write ( nunit , format ) R1i32 else write ( nunit , * ) R1i32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1i32 else write ( * , * ) message , R1i32 end if else if ( present ( format )) then write ( * , format ) R1i32 else write ( * , * ) R1i32 end if end if end if end if ! Write optional rank 1 integer arrays if ( present ( R1i64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1i64 else write ( nunit , * ) message , R1i64 end if else if ( present ( format )) then write ( nunit , format ) R1i64 else write ( nunit , * ) R1i64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1i64 else write ( * , * ) message , R1i64 end if else if ( present ( format )) then write ( * , format ) R1i64 else write ( * , * ) R1i64 end if end if end if end if ! Write optional rank 1 real arrays if ( present ( R1r32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1r32 else write ( nunit , * ) message , R1r32 end if else if ( present ( format )) then write ( nunit , format ) R1r32 else write ( nunit , * ) R1r32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1r32 else write ( * , * ) message , R1r32 end if else if ( present ( format )) then write ( * , format ) R1r32 else write ( * , * ) R1r32 end if end if end if end if ! Write optional rank 1 real arrays if ( present ( R1r64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1r64 else write ( nunit , * ) message , R1r64 end if else if ( present ( format )) then write ( nunit , format ) R1r64 else write ( nunit , * ) R1r64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1r64 else write ( * , * ) message , R1r64 end if else if ( present ( format )) then write ( * , format ) R1r64 else write ( * , * ) R1r64 end if end if end if end if ! Write optional rank 1 complex arrays if ( present ( R1c32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1c32 else write ( nunit , * ) message , R1c32 end if else if ( present ( format )) then write ( nunit , format ) R1c32 else write ( nunit , * ) R1c32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1c32 else write ( * , * ) message , R1c32 end if else if ( present ( format )) then write ( * , format ) R1c32 else write ( * , * ) R1c32 end if end if end if end if ! Write optional rank 1 complex arrays if ( present ( R1c64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R1c64 else write ( nunit , * ) message , R1c64 end if else if ( present ( format )) then write ( nunit , format ) R1c64 else write ( nunit , * ) R1c64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R1c64 else write ( * , * ) message , R1c64 end if else if ( present ( format )) then write ( * , format ) R1c64 else write ( * , * ) R1c64 end if end if end if end if !=================================================== ! Write optional rank 2 arrays !=================================================== ! Write optional rank 2 integer arrays if ( present ( R2i32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2i32 else write ( nunit , * ) message , R2i32 end if else if ( present ( format )) then write ( nunit , format ) R2i32 else write ( nunit , * ) R2i32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2i32 else write ( * , * ) message , R2i32 end if else if ( present ( format )) then write ( * , format ) R2i32 else write ( * , * ) R2i32 end if end if end if end if ! Write optional rank 2 integer arrays if ( present ( R2i64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2i64 else write ( nunit , * ) message , R2i64 end if else if ( present ( format )) then write ( nunit , format ) R2i64 else write ( nunit , * ) R2i64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2i64 else write ( * , * ) message , R2i64 end if else if ( present ( format )) then write ( * , format ) R2i64 else write ( * , * ) R2i64 end if end if end if end if ! Write optional rank 2 real arrays if ( present ( R2r32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2r32 else write ( nunit , * ) message , R2r32 end if else if ( present ( format )) then write ( nunit , format ) R2r32 else write ( nunit , * ) R2r32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2r32 else write ( * , * ) message , R2r32 end if else if ( present ( format )) then write ( * , format ) R2r32 else write ( * , * ) R2r32 end if end if end if end if ! Write optional rank 2 real arrays if ( present ( R2r64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2r64 else write ( nunit , * ) message , R2r64 end if else if ( present ( format )) then write ( nunit , format ) R2r64 else write ( nunit , * ) R2r64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2r64 else write ( * , * ) message , R2r64 end if else if ( present ( format )) then write ( * , format ) R2r64 else write ( * , * ) R2r64 end if end if end if end if ! Write optional rank 2 complex arrays if ( present ( R2c32 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2c32 else write ( nunit , * ) message , R2c32 end if else if ( present ( format )) then write ( nunit , format ) R2c32 else write ( nunit , * ) R2c32 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2c32 else write ( * , * ) message , R2c32 end if else if ( present ( format )) then write ( * , format ) R2c32 else write ( * , * ) R2c32 end if end if end if end if ! Write optional rank 2 complex arrays if ( present ( R2c64 )) then if ( present ( file )) then if ( present ( message )) then if ( present ( format )) then write ( nunit , format ) message , R2c64 else write ( nunit , * ) message , R2c64 end if else if ( present ( format )) then write ( nunit , format ) R2c64 else write ( nunit , * ) R2c64 end if end if else if ( present ( message )) then if ( present ( format )) then write ( * , format ) message , R2c64 else write ( * , * ) message , R2c64 end if else if ( present ( format )) then write ( * , format ) R2c64 else write ( * , * ) R2c64 end if end if end if end if ! Close the file if it was opened if ( present ( file )) close ( nunit ) end subroutine impure_write !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine impure_timer_start ( t ) use fortime implicit none type ( timer ), intent ( out ) :: t call t % timer_start () end subroutine impure_timer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi subroutine impure_timer_stop ( t , message ) use fortime implicit none type ( timer ), intent ( out ) :: t character ( * ), intent ( in ), optional :: message call t % timer_stop ( message = message ) end subroutine impure_timer_stop !===============================================================================","tags":"","loc":"sourcefile/fordebug_smod.f90.html"},{"title":"fordebug.f90 – ForDebug","text":"Files dependent on this one sourcefile~~fordebug.f90~~AfferentGraph sourcefile~fordebug.f90 fordebug.f90 sourcefile~demo.f90 demo.f90 sourcefile~demo.f90->sourcefile~fordebug.f90 sourcefile~fordebug_smod.f90 fordebug_smod.f90 sourcefile~fordebug_smod.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module fordebug use iso_fortran_env , only : int32 , int64 , real32 , real64 use fortime , only : timer implicit none private public pwrite , timer , ptimer_start , ptimer_stop interface !=============================================================================== !> author: Seyed Ali Ghasemi pure module subroutine pwrite (& message , format , file , & R0i32 , R0r32 , R0c32 , R0i64 , R0r64 , R0c64 , R0ch , & R1i32 , R1r32 , R1c32 , R1i64 , R1r64 , R1c64 , & R2i32 , R2r32 , R2c32 , R2i64 , R2r64 , R2c64 , & access ) include 'pwrite.inc' end subroutine pwrite !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure module subroutine ptimer_start ( t ) type ( timer ), intent ( out ) :: t end subroutine ptimer_start !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure module subroutine ptimer_stop ( t , message ) type ( timer ), intent ( out ) :: t character ( len =* ), intent ( in ), optional :: message end subroutine ptimer_stop !=============================================================================== end interface end module fordebug","tags":"","loc":"sourcefile/fordebug.f90.html"},{"title":"demo.f90 – ForDebug","text":"This file depends on sourcefile~~demo.f90~~EfferentGraph sourcefile~demo.f90 demo.f90 sourcefile~fordebug.f90 fordebug.f90 sourcefile~demo.f90->sourcefile~fordebug.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program demo use iso_fortran_env , only : rk => real64 implicit none real ( rk ), dimension (:), allocatable :: y call pure_subroutine ( 1 0.0_rk , 7 , y ) contains pure subroutine pure_subroutine ( x , n , y ) use fordebug implicit none real ( rk ), intent ( in ) :: x integer , intent ( in ) :: n real ( rk ), intent ( out ), allocatable :: y (:) integer :: i type ( timer ) :: t ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'x = ' , R0r64 = x , format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 int32 with a message and format. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' ) ! Write Rank 0 int32 with a message and format to a file. message and format are optional call pwrite ( message = 'n = ' , R0i32 = n , format = '(a,i3)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 character with a format. format is optional call pwrite ( R0ch = 'start loop' , format = '(a)' ) ! Write Rank 0 character with a format to a file. format, access are optional call pwrite ( R0ch = 'start loop' , format = '(a)' , file = 'example/demo.txt' , access = 'append' ) allocate ( y ( n )) y ( 1 ) = 0.0_rk ! start pure timer call ptimer_start ( t ) do concurrent ( i = 2 : n ) y ( i ) = y ( i - 1 ) + x ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y(i) = ' , R0r64 = y ( i ), format = '(a,f7.3)' , file = 'example/demo.txt' , access = 'append' ) end do ! stop pure timer call ptimer_stop ( t ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' ) ! format is optional ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( R0ch = 'end loop' , format = '(a)' , file = 'example/demo.txt' , access = 'append' ) ! Print Rank 0 real64 with a message and format. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y ) ! Write Rank 0 real64 with a message and format to a file. message and format are optional call pwrite ( message = 'y = ' , R1r64 = y , file = 'example/demo.txt' , access = 'append' ) end subroutine pure_subroutine end program demo","tags":"","loc":"sourcefile/demo.f90.html"}]}